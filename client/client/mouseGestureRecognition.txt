using System;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace WindowsFormsApplication3
{
    public partial class Form1 : Form
    {
        /* FIELDS */

        // zegar
        private readonly Timer _timer = new Timer();

        // opóŸnienie zegara
        private int delay;

        // indeks w tablicy 'moves' do którego ma zostaæ wpisany numer ruchu kursora  
        private int index;
        
        // tablica wykonanych ruchów
        private int[] moves;

        // lista wczytanych gestów
        private LinkedList<int[]> list;

        // aktualna pozycja kursora na ekranie
        private Point pCurrent;

        // wczeœniejsza pozycja kursora na ekranie
        private Point pPrevious;

        // aktualnie wykonany ruch kursorem
        int rc;

        // wczeœniejszy wykonany ruch kursorem
        int rp;

        // licznik - wskazuje czas od ostatniego ruchu kursorem
        private int n;

        // zmienna wskazuj¹ca czy kursor siê porusza
        private bool moving;

        /* CONSTRUCTOR */
        public Form1()
        {
            InitializeComponent();

            // inicjalizacja parametrów programu
            init();
        }

        // inicjalizacja parametrów programu
        private void init()
        {
            delay = 30;
            index = 0;
            n = 0;
            moving = false;
            moves = new int[10];
            list = new LinkedList<int[]>();
            rp = -1;

            // pobranie aktualnych pozyci kursora na ekranie
            pPrevious = new Point(Cursor.Position.X, Cursor.Position.Y);

            // inicjalizacja tablicy 'moves', -1 -> brak ruchu
            for (int i = 0; i < moves.Length; i++)
            {
                moves[i] = -1;
            }

            // inicjalizacja zegra
            _timer.Interval = delay;
            _timer.Tick += TimerTick;
            _timer.Enabled = true;

            // wczytanie gestów z pliku
            readFromFile("shapes.dat");
            //printListOnConsole();
        }


        /* METHODS */

        // metoda do wyszukiwania gestów z tablicy 'moves'
        private int findPattern()
        {
            // indeks wyszukiwania w tablicy 'moves'
            int start;

            // indeks wyszukiwania w tablicy 'tab'
            int i; 

            // dla ka¿dego gestu z listy
            foreach (int[] tab in list)
            {
                start = (moves.Length - tab.Length + 1 + index) % moves.Length;
                for (i = 1; i < tab.Length; i++)
                {
                    // jeœli s¹ ró¿ne to przerywany
                    if (tab[i] != moves[start])
                    {
                        break;
                    }

                    // jeœli s¹ zgodne to porównujemy dalej
                    start++;
                    start = start % moves.Length;
                }

               
                if (i == tab.Length)
                {
                    // je¿eli tu jesteœmy to znaczy ¿e odnaleŸliœmy gest
                    // czyœcimy tablicê 'moves' i zwracmy odnale¿iony gest
                    clear();
                    return tab[0];
                }
            }

            // w przypadku braku pozytywnych wyników wyszukiwania zwracamy -1
            return -1;
        }

        // metoda do czyœcimy tablicê 'moves'
        private void clear()
        {
            for (int i = 0; i < moves.Length; i++)
                moves[i] = -1;
        }

        // metoda wczytuj¹ca do listy gesty z pliku, nazwa pliku podawana jako argument
        private void readFromFile(string fname)
        {
            string line = "";
            string[] p;
            int[] pint;
            using (StreamReader sr = new StreamReader(fname))
            {
                // wczytywanie linia po linie do momentu natrafienia na koniec pliku  
                while ((line = sr.ReadLine()) != null)
                {

                    line = line.Trim();

                    // je¿eli linia zaczyna siê od '//' to traktujemy j¹ jako komentarz - pomijamy 
                    if (!line.StartsWith("//") && !line.Equals(""))
                    {

                        // podzia³ wczytanej linie - separator = ' '
                        p = line.Split(' ');
                        pint = new int[p.Length];
                        for (int i = 0; i < p.Length; i++)
                            pint[i] = int.Parse(p[i]);

                        // dodanie gestu do listy
                        list.AddFirst(pint);
                    }
                }
            }
        }

        // metoda pomocnicza - wyœwitla znane gesty do okna konsoli 
        public void printListOnConsole()
        {

            Console.Write("\n\n[ ");
            foreach (int[] tab in list)
            {
                foreach (int i in tab)
                    Console.Write(i + " ");
                Console.WriteLine();
            }
            Console.Write("]\n");
        }


        // metoda przeliczaj¹ca pozycje kursora na odpowiedni ruch
        // parametry:
        // Point c - aktualna pozycja kursora na ekranie
        // Point p - wczeœniejsza pozycja kursora na ekranie
        // eps - maksymalna odleg³oœæ do której nie wyznaczamy nowego ruchu
        private int calculate(Point c, Point p, int eps)
        {
            // wyznacznie odleg³oœci miêdzy punktamu c i p
            int r = (int)distance(c, p);

            // obwód okrêgu
            double l = (2 * Math.PI * r) / 8.0;

            // jeœli odleg³oœæ jest mniejsza to zwracamy -1 -> brak ruchu
            if (r > eps)
            {
                // kierunek w górê
                if (distance(new Point(p.X, p.Y - r), c) < l)
                    return 0;
                // kierunek w prawo
                if (distance(new Point(p.X + r, p.Y), c) < l)
                    return 1;
                // kierunek w dó³
                if (distance(new Point(p.X, p.Y + r), c) < l)
                    return 2;
                // kierunek w lewo
                if (distance(new Point(p.X - r, p.Y), c) < l)
                    return 3;
                // brak ruchu
                else
                    return -1;
            }
            else
            {
                return -1;
            }
        }

        // metoda do obliczania odleg³oœci miêdzy dwoma punktami - odleg³oœc euklidesowa
        private double distance(Point c, Point p)
        {
            double dX = p.X - c.X;
            double dY = p.Y - c.Y;
            double multi = dX * dX + dY * dY;
            double rad = Math.Round(Math.Sqrt(multi), 3);

            return rad;
        }

        // metoda wykonywana w ka¿dej iteracji
        void TimerTick(object sender, EventArgs e)
        {
            // ustalenie aktualnych pozycji kursora
            int x = Cursor.Position.X;
            int y = Cursor.Position.Y;
            pCurrent = new Point(x, y);

            // je¿eli odleg³oœæ miêdzy punktami jest wiêksza od zera to oznacza ¿e kursor siê porusza
            if (distance(pCurrent, pPrevious) > 0)
            {
                moving = true;
                n = 0;
            }
            // w przeciwnym razie ustawiamy 'moving' na false i zaczynamy liczyæ czas o zakoñczenia ruchu
            else
            {
                moving = false;
                n++;
            }

            // je¿eli po up³yniêciu wyznaczonego czasu, kursor nie zosta³ poruszony to czyœcimy wyliczone ruchy
            if (1500 / delay < n)
            {
                clear();
            }

            // przeliczenie pozycji kursora na odpowiedni ruch
            rc = calculate(pCurrent, pPrevious, delay);

                // jeœli jest to nowy ruch, inny od poprzedniego
                if (rc != -1 && rc != rp)
                {
                    // wpisujemy go w odpowiednie miejsce w tablicy 'moves'
                    rp = rc;
                    moves[index] = rc;
                    index++;
                    index = index % moves.Length;

                    // sprawdzenie czy tablica 'moves' zawiera znany nam gest
                    int pattern = findPattern();

                    // jeœli tak to wykonujemy czynnoœæ odpowiedni¹ do tego gestu 
                    if (pattern != -1)
                    {
                        if (pattern == 0)
                        {
                            // pobieranie œcie¿ki do folderu - œcie¿ka jako ³añcuch tekstowy
                            string myComputerPath = Environment.GetFolderPath(Environment.SpecialFolder.MyComputer);

                            //uruchamiamy explorer i wskazujemy na zadan¹ œcie¿kê - "mój komputer" 
                            System.Diagnostics.Process.Start("explorer", myComputerPath);
                        }
                        else if (pattern == 1)
                        {
                            // pobieranie œcie¿ki do folderu - œcie¿ka jako ³añcuch tekstowy
                            string myDocumentsPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);

                            //uruchamiamy explorer i wskazujemy na zadan¹ œcie¿kê - "moje dokumenty"
                            System.Diagnostics.Process.Start("explorer", myDocumentsPath);
                        }
                        else if (pattern == 2)
                        {
                        // uruchoienie wyszukiwarki google
                        string url = "http://google.com/";
                            System.Diagnostics.Process.Start(url);
                        }
                        else if (pattern == 3)
                        {
                            // uruchomienie panelu sterowania
                            System.Diagnostics.Process.Start("control");
                        }

                    }

            }

            pPrevious = pCurrent;


            if (n > 10000)
                n = 0;
        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }
    }
}
